# GOA - grogu on ASIC
`GOA` stands for `grogu on ASIC`. It is a reduced version of the [CORTEZ
chip](https://github.com/scorbetta/CORTEZ) targeting the Tiny Tapeout 6 run. The `grogu` part comes
from the register file design utilities [grogu](https://github.com/scorbetta/grogu).

The `GOA` design is made of a single neuron with 2 (two) inputs. The register file thus contains 4
(four) registers: 2 (two) contain values for the weights, 1 (one) contains value for the bias and 1
(one) contains the result computed by the neuron arithmetic core. The neuron works on 8 (eight) bits
fixed-point arithmetic with 5 (five) reserved for the fraction.

## Pinout
The top-level `tt_um_scorbetta_goa` adheres to the following pinout:

| PIN | DIRECTION | ROLE |
|-|-|-|
| `ui_in[0]` | input | Core clock, generated by the FPGA |
| `ui_in[1]` | input | Active-low core reset |
| `ui_in[2]` | input | `SCI_CSN` |
| `ui_in[3]` | input | `SCI_REQ` |
| `ui_in[4]` | input | Load value in |
| `ui_in[5]` | input | Value in |
| `ui_in[6]` | input | Shift result out |
| `ui_in[7]` | input | Neuron trigger |
| `uo_out[0]` | output | `SCI_RESP` |
| `uo_out[1]` | output | `SCI_ACK` |
| `uo_out[2]` | output | Result out |
| `uo_out[3]` | output | Neuron ready |
| `uo_out[4]` | output | Neuron done |
| `uo_out[5]` | output | Debug counter [5] |
| `uo_out[6]` | output | Debug counter [6] |
| `uo_out[7]` | output | Debug counter [7] |
| `uio_in[7:0]` | input | Unused |
| `uio_out[7:0]` | output | Unused |
| `uio_oe[7:0]` | output | Unused, tied to 8'h0 |
| `ena` | input | 1'b1 when design is enabled |
| `clk` | input | RP2040 clock, used for debug |
| `rst_n`| input | Active-low reset |

## Configuration
The configuration of the neuron is implemented by means of local registers that hold the values for
the weights and the bias. In addition, control registers are used to trigger the neuron operations.

Configuration runs through the Scalable Configuration Interface (SCI), a serial SPI-inspired
interface for dense designs. The SCI interface for one Master and `N` Slaves is composed of 4 (four)
signals (mapping to the `tt_um_scorbetta_goa` pins is reported in the Pinout section).

| SIGNAL | WIDTH | DIRECTION | ROLE |
|-|-|-|-|
| `SCI_CSN` | `N` | Master-to-Slave | Active-low peripheral select |
| `SCI_REQ` | 1 | Master-to-Slave | Request |
| `SCI_RESP` | 1 | Slave-to-Master | Response |
| `SCI_ACK` | 1 | Slave-to-Master | Ack |

For detailed information on the SCI protocol please refer to [this page](TBD).

# External hardware
The main clock `clk` is generated by the on-board RP2040 chip. It is used solely for debug purposes.
It drives an 8 (eight) bit counter, whose 3 (three) MSBs are rerouted to `uo_out` (please refer to
the pinout table).

The core clock is instead drawn from `ui_in[0]`. This is generated by an FPGA residing on an
external board. `ui_in[0]` and `clk` are mesochronous, and they never interact. The use of an
external clock is required, since the SCI interface (also driven by the FPGA) needs proper
synchronization.

## FPGA control loop
The external FPGA runs a simple control loop:

```
// Wait for ready signal
wait_for(uo_out[3] == 1);

// Basic connectivity test
repeat(10) {
    sci_write_debug_reg();
    sci_read_debug_reg();
    verify();
}

// Configure weights and bias
sci_write_weights();
sci_write_bias();

// Stimuli loop
forever {
    // Send random values one at a time
    repeat(2) {
        load_value(random);
        wait_for(uo_out[3] == 1);
        pulse(ui_in[7]);
    }

    // Wait for result
    wait_for(uo_out[4] == 1);
    shift_result();

    // Do something with result
    ...
}
```

# How to test
TBD
