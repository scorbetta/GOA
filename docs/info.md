# GOA - grogu on ASIC
`GOA` stands for `grogu on ASIC`. It is a reduced version of the [CORTEZ
chip](https://github.com/scorbetta/CORTEZ) targeting the Tiny Tapeout 6 run. The `grogu` part comes
from the register file design utilities [grogu](https://github.com/scorbetta/grogu).

The `GOA` design is made of a single neuron with 2 (two) inputs. The register file thus contains 4
(four) registers: 2 (two) contain values for the weights, 1 (one) contains value for the bias and 1
(one) contains the result computed by the neuron arithmetic core. The neuron works on 8 (eight) bits
fixed-point arithmetic with 5 (five) reserved for the fraction.

# Neuron internals
The next figure shows the simplified block diargram of the Neuron.

![Neuron architecture](Neuron.png)

The arithmetic pipeline is composed of a number of fixed-point units: multiplier, adder for
accumulator and bias, activation function. These primitives are shared, so that a centralized
control engine (`NCE`) dispatches one value at a time to the proper block. `WEIGHTS` matrix is
externally stored in a local register file, an instance of `grogu`.

The `NCE` expects exactly `NUM_INPUTS` input values. For each of them, the following process is
executed through the pipeline:

1. Multiply current value by its respective weight;
2. Accumulate the value.

Once all values have been received, bias is added and the non-linear activation function is used to
determine the output solution.

## Fixed-point
The entire pipeline works with fixed-point arithmetic. This reduces the complexity of the design.
For the Tiny Tapeout run, the fixed-point configuration is: 8 (eight) bits word with 5 (five) bits
reserved to the fractional part. All fixed-point operations wrap.

## Non-linear activation function
`tanh()` is the chosen non-linear activation function. Thanks to its mathematical properties, it is
interesting designing a fully digital filter that implements a piecewise approximation.

Linear interpolation between successive points is carefully chosen to minimize the error. The points
where the `tanh()` function is split are chosen by looking at up to the 4-th derivative. Since the
`tanh()` function is odd symmetric, the digital implementation focuses on half of the problem in the
1st quadrant. The other half of the problem on the 3rd quadrant is derived. The output is shown.

![Derivatives](plot_derivatives.png)

## Scalable Configuration Interface
The SCI interface has been designed for the `CORTEZ` chip to address dense register files with a
fairly large amount of registers. The SCI is designed to reduce wires and congestion. It consists of
an half-duplex communication mechanism with request/ack pairs, useful for low-speed peripheral
register access. Is is also latency insensitive. The SCI is inspired by the SPI protocol, with
tri-state bus and active-low chip select.

For the single neuron case, the SCI bus is not tri-stated, since there is one single peripheral.
This simplfies the implementation.

In general, the SCI interface for one Master and `N` Slaves is composed of 4 (four) signals (mapping
to the `tt_um_scorbetta_goa` pins is reported in the Pinout section).

| SIGNAL | WIDTH | DIRECTION | ROLE |
|-|-|-|-|
| `SCI_CSN` | `N` | Master-to-Slave | Active-low peripheral select |
| `SCI_REQ` | 1 | Master-to-Slave | Request |
| `SCI_RESP` | 1 | Slave-to-Master | Response |
| `SCI_ACK` | 1 | Slave-to-Master | Ack |

For detailed information on the SCI protocol please refer to [this page](TBD).

Examples of Write and Read accesses are shown.

![Write access](SCI_Write.png)

![Read access](SCI_Read.png)

# Pinout
The top-level `tt_um_scorbetta_goa` adheres to the following pinout:

| PIN | DIRECTION | ROLE |
|-|-|-|
| `ui_in[0]` | input | Core clock, generated by the FPGA |
| `ui_in[1]` | input | Active-low core reset |
| `ui_in[2]` | input | `SCI_CSN` |
| `ui_in[3]` | input | `SCI_REQ` |
| `ui_in[4]` | input | Load value in |
| `ui_in[5]` | input | Value in |
| `ui_in[6]` | input | Shift result out |
| `ui_in[7]` | input | Neuron trigger |
| `uo_out[0]` | output | `SCI_RESP` |
| `uo_out[1]` | output | `SCI_ACK` |
| `uo_out[2]` | output | Result out |
| `uo_out[3]` | output | Neuron ready |
| `uo_out[4]` | output | Neuron done |
| `uo_out[5]` | output | Debug counter [5] |
| `uo_out[6]` | output | Debug counter [6] |
| `uo_out[7]` | output | Debug counter [7] |
| `uio_in[7:0]` | input | Unused |
| `uio_out[7:0]` | output | Unused |
| `uio_oe[7:0]` | output | Unused, tied to 8'h0 |
| `ena` | input | 1'b1 when design is enabled |
| `clk` | input | RP2040 clock, used for debug |
| `rst_n`| input | Active-low reset |

# Configuration
The configuration of the neuron is implemented by means of local registers that hold the values for
the weights and the bias. In addition, control registers are used to trigger the neuron operations.

# External hardware
The main clock `clk` is generated by the on-board RP2040 chip. It is used solely for debug purposes.
It drives an 8 (eight) bit counter, whose 3 (three) MSBs are rerouted to `uo_out` (please refer to
the pinout table).

The core clock is instead drawn from `ui_in[0]`. This is generated by an FPGA residing on an
external board. `ui_in[0]` and `clk` are mesochronous, and they never interact. The use of an
external clock is required, since the SCI interface (also driven by the FPGA) needs proper
synchronization.

## FPGA control loop
The external FPGA runs a simple control loop:

```
// Wait for ready signal
wait_for(uo_out[3] == 1);

// Basic connectivity test
repeat(10) {
    sci_write_debug_reg();
    sci_read_debug_reg();
    verify();
}

// Configure weights and bias
sci_write_weights();
sci_write_bias();

// Stimuli loop
forever {
    // Send random values one at a time
    repeat(2) {
        load_value(random);
        wait_for(uo_out[3] == 1);
        pulse(ui_in[7]);
    }

    // Wait for result
    wait_for(uo_out[4] == 1);
    shift_result();

    // Do something with result
    ...
}
```

# How to test
TBD
